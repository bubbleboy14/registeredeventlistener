from .listener import EV_PERSIST as EV_PERSIST, EV_READ as EV_READ, EV_SIGNAL as EV_SIGNAL, EV_TIMEOUT as EV_TIMEOUT, EV_WRITE as EV_WRITE
from .registrar import EpollRegistrar as EpollRegistrar, KqueueRegistrar as KqueueRegistrar, PollRegistrar as PollRegistrar, SelectRegistrar as SelectRegistrar, set_sleep as set_sleep, set_turbo as set_turbo
from _typeshed import Incomplete

def override() -> None: ...

running: bool
registrar: Incomplete
threader: Incomplete
verbose: bool
supported_methods: Incomplete
mapping: Incomplete

def log(text) -> None: ...

class Thread_Checker:
    active: Incomplete
    def __init__(self, threaded) -> None: ...
    checker: Incomplete
    sleeper: Incomplete
    def go(self) -> None: ...
    def stop(self) -> None: ...
    def release(self, *args): ...
    def check(self): ...

def check_init() -> None: ...
def get_registrar(method): ...
def set_verbose(isverb) -> None: ...
def initialize(methods=..., options=...): ...

SAFE_READ: bool

def safe_read() -> None: ...
def read(sock, cb, *args): ...
def write(sock, cb, *args): ...
def error(sock, cb, *args): ...
def timeout(delay, cb, *args): ...
def signal(sig, callback, *args): ...
def dispatch() -> None: ...
def loop() -> None: ...
def report(): ...
def is_running(): ...
def abort() -> None: ...
def abort_branch() -> None: ...
def init() -> None: ...
def event(callback, arg: Incomplete | None = ..., evtype: int = ..., handle: Incomplete | None = ...): ...
def thread(callback) -> None: ...
def tick(): ...
def start() -> None: ...
def stop() -> None: ...
